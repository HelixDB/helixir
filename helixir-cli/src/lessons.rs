use std::vec;

#[derive(Debug)]
pub struct Lesson {
    pub id: usize,
    pub title: String,
    pub instructions: String,
    pub hints: Vec<String>,
    pub schema_answer: Option<String>,
    pub query_answer: Option<String>,
    pub query_answer_file: Option<String>,
    pub query_name: Option<Vec<String>>,
}

pub fn get_lesson(lesson_id: usize) -> Lesson {
    match lesson_id {
        0 => Lesson {
            id: 0,
            title: "Setup - Initialize HelixDB".into(),
            instructions: "Run 'helix init' to set up your helix instance (you can run it straight in this CLI)".into(),
            hints: vec!["Check if helixdb-cfg folder exists".into()],
            schema_answer: None,
            query_answer: None,
            query_answer_file: None,
            query_name: None,
        },
        1 => Lesson {
            id: 1,
            title: "Schema Design - Nodes".into(),
            instructions: "We will be using HelixDB to model the relationships between continents, countries, and cities as a graph.\nFirst, we have to define what kind of entities/nodes will be in our graph.\nWe will start with 3 types of nodes: continents, countries, and cities.\nThe continent node will have a `name` property, which takes a `String`.\nThe country node will have a `name` property, a `currency` property, a `population` property (`U64`), and a `gdp` property (`F64`).\nThe city node will have a `name` property, a `description` property, and a `zip_codes` property that takes an array of strings.\n\nCreate a Continent , Country , and City node with their respective properties in schema.hx".into(),
            hints: vec!["Use N:: for nodes".into()],
            schema_answer: Some("lesson_answers/lesson1_schema.hx".into()),
            query_answer: None,
            query_answer_file: None,
            query_name: None,
        },
        2 => Lesson {
            id: 2,
            title: "Adding in Edges".into(),
            instructions: "Now that we know what type of nodes are in our schema, we will define the relationships between those nodes.\n For this example, there is a hierarchical pattern where a city is in a country and a country is in a continent.\n\nCreate a Continent_to_Country and Country_to_City edge connecting their respective nodes with no properties in schema.hx.".into(),
            hints: vec!["Use E:: for edges".into()],
            schema_answer: Some("lesson_answers/lesson2_schema.hx".into()),
            query_answer: None,
            query_answer_file: None,
            query_name: None,
        },
        3 => Lesson {
            id: 3,
            title: "Meta Relationships".into(),
            instructions: "In addition to the structural relationships between the nodes, you can also define relationships based on metadata. For example, a country must have a capital city.\n\nCreate a Country_to_Capital edge connecting Country to City in schema.hx".into(),
            hints: vec!["Use E:: for edges".into()],
            schema_answer: Some("lesson_answers/lesson3_schema.hx".into()),
            query_answer: None,
            query_answer_file: None,
            query_name: None,
        },
        4 => Lesson {
            id: 4,
            title: "Defining Vectors".into(),
            instructions: "Vectors in HelixDB allow us to create vector-based searches for semantic similarity.\nA vector is an array of floating-point numbers that represents the semantic meaning of data.\nIn this case, we'll create a vector for city descriptions.\n\nCreate a CityDescription vector with vector property that takes an array of F64".into(),
            hints: vec!["Use E:: for edges".into()],
            schema_answer: Some("lesson_answers/lesson4_schema.hx".into()),
            query_answer: None,
            query_answer_file: None,
            query_name: None,
        },
        5 => Lesson {
            id: 5,
            title: "Basic Node Creation".into(),
            instructions: "Now that we have our schema, we need to write queries to insert the data. The best way to go about this given the structure of our data is to go from top (broad) to bottom (narrow) of the hierarchy.\nFirst, we will start with a basic query to create a continent.\nUsually, creation queries almost always include all the properties of the node in the arguments.\nIn this case, we only need to know the continent's name.\nUse `AddN` to add a `Continent` node with property `name`.\nDon't forget to run helix deploy to start up your helix instance!".into(),
            hints: vec!["Add this header into your query.hx: QUERY createContinent (name: String) =>".into()],
            schema_answer: Some("lesson_answers/lesson4_schema.hx".into()),
            query_answer: Some("query_answers/lesson5.json".into()),
            query_answer_file: None,
            query_name: Some(vec!["createContinent".into()]),
        },
        6 => Lesson {
            id: 6,
            title: "Basic Node Creation".into(),
            instructions: "Most of the nodes in our schema are related to other nodes,\nwhich means that we have to also create edges between them.\nHowever, we can optimize this process by creating both the node\nand the edge connecting it to other existing nodes in one query.\nFor this example, we will create a country node and connect it\nto its corresponding continent node.To do this, we will need to know all\nthe properties of our `Country` node and also the `Continent` node’s id.\nWith that information, we will first create a new `Country` node using `AddN`.\nThen we will get the `Continent`≈ node via the node’s ID so that we can create a\n`Continent_to_Country` edge going from the created `Continent` to `Country` node\nusing `AddE`.We will also do the same thing for creating a city node.".into(),
            hints: vec!["Add this header into your query.hx: QUERY createCity (country_id: ID, name: String, description: String) =>".into(),
            "Add this header into your query.hx: QUERY createCountry (continent_id: ID, name: String, currency: String, population: U64, gdp: F64) =>".into()],
            schema_answer: Some("lesson_answers/lesson4_schema.hx".into()),
            query_answer: Some("query_answers/lesson6.json".into()),
            query_answer_file: Some("lesson_answers/lesson6_queries.hx".into()),
            query_name: Some(vec!["createCountry".into(), "createCity".into()]),
        },
        7 => Lesson {
            id: 7,
            title: "Creating Meta Relationships".into(),
            instructions: "In order to add meta relationships into our graph,\nwe will connect nodes together with the edges that\ndefine the meta relationships. For this example,\nwe will create a Country_to_Capital edge from a Country\nnode to a City node.\n\nWrite a query to set a City node as the capital city of a Country node using their IDs.".into(),
            hints: vec!["Add this header into your query.hx: QUERY setCapital (country_id: ID, city_id: ID) =>".into()],
            schema_answer: Some("lesson_answers/lesson4_schema.hx".into()),
            query_answer: Some("query_answers/lesson7.json".into()),
            query_answer_file: Some("lesson_answers/lesson7_queries.hx".into()),
            query_name: Some(vec!["setCapital".into()]),
        },
        8 => Lesson {
            id: 8,
            title: "Creating Vector Embeddings".into(),
            instructions: "In order to add meta relationships into our graph,\nwe will connect nodes together with the edges that\ndefine the meta relationships. For this example,\nwe will create a Country_to_Capital edge from a Country\nnode to a City node.\n\nWrite a query to set a City node as the capital city of a Country node using their IDs.".into(),
            hints: vec!["Add this header into your query.hx: QUERY embedDescription (city_id: ID, vector: [F64]) =>".into()],
            schema_answer: Some("lesson_answers/lesson4_schema.hx".into()),
            query_answer: Some("query_answers/lesson8.json".into()),
            query_answer_file: Some("lesson_answers/lesson8_queries.hx".into()),
            query_name: Some(vec!["embedDescription".into()]),
        },
        9 => Lesson {
            id: 9,
            title: "Get Nodes by ID".into(),
            instructions: "Now that we know how to create nodes and\ntheir relationships, we need to be able\nto retrieve nodes from our graph. The\nsimplest way is to retrieve nodes when we\nknow their ID. Let's write queries to get\na continent, country, and city node by their\nrespective IDs. Write 3 queries to get\nContinent, Country, and City by node ID.".into(),
            hints: vec!["Add this header into your query.hx: QUERY embedDescription (city_id: ID, vector: [F64]) =>".into()],
            schema_answer: Some("lesson_answers/lesson4_schema.hx".into()),
            query_answer: Some("query_answers/lesson9.json".into()),
            query_answer_file: Some("lesson_answers/lesson9_queries.hx".into()),
            query_name: Some(vec!["getContinent".into(),"getCountry".into(), "getCity".into()]),
        },
        10 => Lesson {
            id: 10,
            title: "Get All Nodes of Type".into(),
            instructions: "In addition to retrieving nodes by ID, we\noften want to retrieve all nodes of a certain\ntype. Since we have a hierarchical structure,\nwe willalso want to get all countries within a\ncontinent and all cities within a country.\nWrite 3 queries to get all `Continent`, `Country`,\nand `City` nodes.Write 2 queries to get all `Country`\nand `City` nodes by their parent IDs.".into(),
            hints: vec!["Add this header into your query.hx: QUERY embedDescription (city_id: ID, vector: [F64]) =>".into()],
            schema_answer: Some("lesson_answers/lesson4_schema.hx".into()),
            query_answer: Some("query_answers/lesson10.json".into()),
            query_answer_file: Some("lesson_answers/lesson10_queries.hx".into()),
            query_name: Some(vec!["getAllContinents".into(),"getAllCountries".into(), "getAllCities".into(),"getCountriesInContinent".into(), "getCitiesInContinent".into()]),
        },
        11 => Lesson {
            id: 11,
            title: "Get Nodes by Meta Relationship".into(),
            instructions: "Similar to getting nodes by their hierarchical relationships, we can also get nodes via their meta relationships. For this example, we will retrieve the capital city of a country. We'll do this by traversing the `Country_to_Capital` edge from a `Country` node to find its capital `City` node.\n\nWrite a query to get a country's capital `City` node by the country's ID.".into(),
            hints: vec!["Add this header into your query.hx: QUERY getCapital (country_id: ID) =>".into()],
            schema_answer: Some("lesson_answers/lesson4_schema.hx".into()),
            query_answer: Some("query_answers/lesson11.json".into()),
            query_answer_file: Some("lesson_answers/lesson11_queries.hx".into()),
            query_name: Some(vec!["getCapital".into()]),
        },
        12 => Lesson {
            id: 12,
            title: "Get Node Properties".into(),
            instructions: "Sometimes we don't need the full node, just a few specific properties. For example, we can display only the names and populations of countries without pulling in the entire object. In this case, we can use property selection syntax to retrieve just the fields we care about. This allows for more efficient querying and cleaner data handling when building visualizations or summaries.\n\nWrite a query to get each country's `name` and `population`".into(),
            hints: vec!["Add this header into your query.hx: QUERY getCountryNames () =>".into(), "Use property selection syntax ::={name, population}".into()],
            schema_answer: Some("lesson_answers/lesson4_schema.hx".into()),
            query_answer: Some("query_answers/lesson12.json".into()),
            query_answer_file: Some("lesson_answers/lesson12_queries.hx".into()),
            query_name: Some(vec!["getCountryNames".into()]),
        },
        13 => Lesson {
            id: 13,
            title: "Get Nodes by Property".into(),
            instructions: "In addition to retrieving nodes by their ID or relationship, we often need to find nodes based on their properties. This allows for more flexible querying of our graph database. Let's write queries to retrieve nodes by specific properties they contain.\n\nWrite 3 queries that get the `Continent`, `Country`, and `City` nodes by their names.".into(),
            hints: vec![
                "Add this header into your query.hx: QUERY getContinentByName (continent_name: String) =>".into(), 
                "Use WHERE clause with property matching: ::WHERE(_::{name}::EQ(continent_name))".into()
            ],
            schema_answer: Some("lesson_answers/lesson4_schema.hx".into()),
            query_answer: Some("query_answers/lesson13.json".into()),
            query_answer_file: Some("lesson_answers/lesson13_queries.hx".into()),
            query_name: Some(vec!["getContinentByName".into(), "getCountryByName".into(), "getCityByName".into()]),
        },
        _ => Lesson {
            id: lesson_id,
            title: "Lesson Not Found".into(),
            instructions: "This lesson hasn't been implemented yet.".into(),
            hints: vec!["Try going back to a previous lesson.".into()],
            schema_answer: None,
            query_answer: None,
            query_answer_file: None,
            query_name: None
        }
    }
}
